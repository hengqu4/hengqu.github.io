<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat_2.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat_2.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hengqu4.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://hengqu4.github.io/2023/07/31/redis-knowledge/index.html">
<meta property="og:site_name" content="Hengqu4">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-07-31T02:54:48.000Z">
<meta property="article:modified_time" content="2023-08-18T08:59:38.924Z">
<meta property="article:author" content="hengqu4">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="非关系型数据库">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hengqu4.github.io/2023/07/31/redis-knowledge/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hengqu4.github.io/2023/07/31/redis-knowledge/","path":"2023/07/31/redis-knowledge/","title":"Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis | Hengqu4</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hengqu4</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">The best time is now.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">redis是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">5种数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">2.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-%E6%95%A3%E5%88%97%E8%A1%A8-%E5%93%88%E5%B8%8C"><span class="nav-number">2.2.</span> <span class="nav-text">Hash 散列表&#x2F;哈希</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-%E5%88%97%E8%A1%A8-%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">List 列表&#x2F;链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-%E9%9B%86%E5%90%88"><span class="nav-number">2.4.</span> <span class="nav-text">Set 集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="nav-number">2.5.</span> <span class="nav-text">zset 有序集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Geospatial-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.6.</span> <span class="nav-text">Geospatial 地理位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hyperloglog-%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="nav-number">2.7.</span> <span class="nav-text">Hyperloglog 基数统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmap-%E4%BD%8D%E5%9B%BE%E5%9C%BA%E6%99%AF"><span class="nav-number">2.8.</span> <span class="nav-text">Bitmap 位图场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">单线程还是多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">5.1.</span> <span class="nav-text">RDB持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">AOF持久化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.</span> <span class="nav-text">事务实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">7.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E7%A7%8D%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">3种集群模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8EMaster-Slave%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">主从Master-Slave模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">10.</span> <span class="nav-text">主从不一致</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">11.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">12.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9"><span class="nav-number">13.</span> <span class="nav-text">缓存穿透、击穿、雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">13.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">13.2.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E9%9B%AA%E5%B4%A9"><span class="nav-number">13.3.</span> <span class="nav-text">缓冲雪崩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5-6%E7%A7%8D"><span class="nav-number">14.</span> <span class="nav-text">淘汰策略 6种</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-3%E7%A7%8D"><span class="nav-number">15.</span> <span class="nav-text">删除策略 3种</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%A4%8D%E5%88%B6AOF%E6%96%87%E4%BB%B6%E6%97%B6%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F"><span class="nav-number">16.</span> <span class="nav-text">在复制AOF文件时如何处理过期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98%E5%92%8CMySQL%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">17.</span> <span class="nav-text">Redis缓存和MySQL不一致</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0%E7%AD%96%E7%95%A5"><span class="nav-number">17.1.</span> <span class="nav-text">延时双删策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="nav-number">17.2.</span> <span class="nav-text">删除缓存重试机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96biglog%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="nav-number">17.3.</span> <span class="nav-text">读取biglog异步删除缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-number">18.</span> <span class="nav-text">缓存预热</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6"><span class="nav-number">19.</span> <span class="nav-text">缓存如何回收</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hengqu4"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">hengqu4</p>
  <div class="site-description" itemprop="description">Master of Software Engineering</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hengqu4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hengqu4" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jxy2000910@gmail.com" title="E-Mail → mailto:jxy2000910@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hengqu4.github.io/2023/07/31/redis-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="hengqu4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hengqu4">
      <meta itemprop="description" content="Master of Software Engineering">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis | Hengqu4">
      <meta itemprop="description" content=" ">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-31 10:54:48" itemprop="dateCreated datePublished" datetime="2023-07-31T10:54:48+08:00">2023-07-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-18 16:59:38" itemprop="dateModified" datetime="2023-08-18T16:59:38+08:00">2023-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description"> </div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h2><p>一种运行速度很快，并发很强的跑在内存上的NoSql数据库。<br>支持键到五种数据类型的映射。</p>
<blockquote>
<p>采用了多路复用io阻塞机制，<br>数据结构简单，操作节省时间，<br>运行在内存中，自然速度快。</p>
</blockquote>
<h2 id="5种数据类型"><a href="#5种数据类型" class="headerlink" title="5种数据类型"></a>5种数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string 是 redis 最基本的类型，是简单的Key-Value模型，Value可以是字符串，也可以是数字。一个 key 对应一个 value。<br>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。<br>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新增key1,值为hello</span></span><br><span class="line">set key1 hello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置一个键为key2，值为world，并且30秒后过期</span></span><br><span class="line">set key2 30 world</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果key不存在，则创建一个key，如果key存在，则创建失败并返回0。</span></span><br><span class="line">setnx key3 testaaa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">setnx在分布式锁中经常使用到</span></span><br></pre></td></tr></table></figure>
<h3 id="Hash-散列表-哈希"><a href="#Hash-散列表-哈希" class="headerlink" title="Hash 散列表&#x2F;哈希"></a>Hash 散列表&#x2F;哈希</h3><p>hash 是 字符 filed 和 value 之间的映射表，所以非常适合用于存储对象（比如：一个用户有多个属性字段，如：名称，年龄等等。）<br>Hash 适合存储对象结构，或者数据库表的字段结构。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEL key1</span><br><span class="line"></span><br><span class="line">HMSET key1 field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;OK&quot;</span></span></span><br><span class="line"></span><br><span class="line">HGET key1 field1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"></span><br><span class="line">HGET key1 field2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;World&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>hash是最接近关系数据库结构的数据类型，，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储，主要有以下2种存储方式：</p>
<ol>
<li>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化&#x2F;反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</li>
<li>第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</li>
</ol>
<h3 id="List-列表-链表"><a href="#List-列表-链表" class="headerlink" title="List 列表&#x2F;链表"></a>List 列表&#x2F;链表</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。<br>你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<ul>
<li>Lpush：表示的是向链表的左添加，也就是向链表的头添加；</li>
<li>Rpush：表示的是向链表的右添加，也就是向链表的尾添加。</li>
</ul>
<ol>
<li>如果key不存在，就创建新的链表；</li>
<li>如果key存在就创建新的值；</li>
<li>如果移除了所有的值，空链表，也就代表不存在；</li>
<li>在两边插入或者改动值，效率最高，中间元素相对来说效率会低一点。</li>
</ol>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>Redis 的 Set 是 string 类型的无序集合。<br>在Set集合当中，是不允许有重复的。<br>set是通过hash table(哈希表)实现的，所以添加，删除，查找的复杂度都是 O(1)。<br>对集合我们可以取并集，交集，差集。<br><code>sadd</code>：添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DEL key3</span><br><span class="line">sadd key3 redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(<span class="built_in">integer</span>) 1</span></span><br><span class="line">sadd key3 mongodb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(<span class="built_in">integer</span>) 1</span></span><br><span class="line">sadd key3 rabbitmq</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">(<span class="built_in">integer</span>) 1</span></span><br><span class="line">sadd key3 rabbitmq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(<span class="built_in">integer</span>) 0</span></span><br><span class="line">smembers key3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1) <span class="string">&quot;redis&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2) <span class="string">&quot;rabbitmq&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3) <span class="string">&quot;mongodb&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>zset 和 set 不同的是每个元素都会关联一个double类型的分数score。redis正是通过分数score来为zset中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。</p>
<ul>
<li>zset有序集合的实现方式是哪种数据结构？<blockquote>
<p>跳跃表。</p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEL key4</span><br><span class="line">zadd key4 0 redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(<span class="built_in">integer</span>) 1</span></span><br><span class="line">zadd key4 0 mongodb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(<span class="built_in">integer</span>) 1</span></span><br><span class="line">zadd key4 0 rabbitmq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(<span class="built_in">integer</span>) 1</span></span><br><span class="line">zadd key4 0 rabbitmq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(<span class="built_in">integer</span>) 0</span></span><br><span class="line">ZRANGEBYSCORE key4 0 1000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1) <span class="string">&quot;mongodb&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2) <span class="string">&quot;rabbitmq&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3) <span class="string">&quot;redis&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial 地理位置"></a>Geospatial 地理位置</h3><h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog 基数统计"></a>Hyperloglog 基数统计</h3><h3 id="Bitmap-位图场景"><a href="#Bitmap-位图场景" class="headerlink" title="Bitmap 位图场景"></a>Bitmap 位图场景</h3><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><p>string</p>
<ul>
<li>缓存结构体信息：将结构体json序列化成字符串，然后将字符串保存在redis的value中，将结构体的业务唯一标示作为key；这种保存json的用法用的最多的场景就是缓存用户信息，将用户bean信息转成json再序列化为字符串作为value保存在redis中，将用户id作为key。从代码中获取用户缓存信息就是一个逆过程，根据userid作为key获取到结构体json，然后将json转成java bean。</li>
<li>计数器—点赞,视频播放量,每播放一次就+1。</li>
<li>统计多单位的数量。</li>
<li>粉丝数。</li>
</ul>
</li>
<li><p>hash</p>
<ul>
<li>主要用于存储部分变更数据，比如存储用户信息等。不同于字符串一次序列化整个对象，hash可以对用户结构中的每个字段单独存储。这样当我们需要获取结构体信息时可以进行部分获取，而不用序列化所有字段，而将整个字符串保存的结构体信息只能一次性全部读取。</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li>list列表结构常用来做异步队列使用：将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</li>
<li>list可用于秒杀抢购场景：在商品秒杀场景最怕的就是商品超卖，为了解决超卖问题，我们经常会将库存商品缓存到类似MQ的队列中，多线程的购买请求都是从队列中取，取完了就卖完了，但是用MQ处理的化有点重，这里就可以使用redis的list数据类型来实现，在秒杀前将本场秒杀的商品放到list中，因为list的pop操作是原子性的，所以即使有多个用户同时请求，也是依次pop，list空了pop抛出异常就代表商品卖完了。</li>
<li>消息队列：利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。</li>
<li>消息排队，消息队列（Lpush、Rpop）、栈（Lpush、Lpop）</li>
<li>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。</li>
</ul>
</li>
<li><p>set</p>
<ul>
<li>一些去重的场景里，例如每个用户只能参与一次活动、一个用户只能中奖一次等等去重场景。</li>
<li>微博、用户将所有关注的人都放入到一个set集合当中，将它的粉丝也放在一个集合中。</li>
<li>共同关注、共同爱好、二度好友、QQ的好友推荐（六度分割理论）</li>
</ul>
</li>
<li><p>zset </p>
<ul>
<li>热门排序场景。例如热门歌曲榜单列表，value值是歌曲ID，score是播放次数，这样就可以对歌曲列表按播放次数进行排序。</li>
<li>微博粉丝列表、评论列表等等。可以将value定义为用户ID、评论ID，score定义为关注时间、评论点赞次数等等。</li>
<li>存储班级成绩表、工资表排序。</li>
</ul>
</li>
</ul>
<h2 id="单线程还是多线程"><a href="#单线程还是多线程" class="headerlink" title="单线程还是多线程"></a>单线程还是多线程</h2><p>单线程。</p>
<p>因为Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小。再说了，单线程切换开销小，容易实现既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<ul>
<li><p>如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？</p>
<blockquote>
<p>那也很简单，你多起几个Redis进程就好了。Redis是key-value数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。</p>
</blockquote>
</li>
<li><p>单线程可以处理高并发请求吗？</p>
<blockquote>
<p>当然可以，Redis都实现了。<br>有一点概念需要澄清，并发并不是并行。<br>（相关概念：并发性I&#x2F;O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元）</p>
</blockquote>
</li>
</ul>
<h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>将某个时间点的所有数据都存放到硬盘上。<br>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。<br>恢复时是将快照文件直接读到内存里。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。<br>如果数据量很大，保存快照的时间会很长。</p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>RDB是通过保存数据库中的键值对来记录数据库的状态，AOF 则是通过保存Redis服务器所执行的写命令来记录数据库状态。<br><code>redis.conf</code>配置文件中关于AOF的配置：</p>
<ul>
<li>appendonly：默认值为no，也就是说redis 默认使用的是rdb方式持久化，如果想要开启 AOF 持久化方式，需要将 appendonly 修改为 yes。</li>
<li>appendfilename ：AOF文件名，默认是”appendonly.AOF”</li>
<li>appendfsync：<strong>AOF持久化策略</strong>的配置；<ul>
<li>no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不太安全（不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量）；</li>
<li>always表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低，会严重减低服务器的性能；</li>
<li>everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。<strong>通常选择 everysec</strong> ，兼顾安全性和效率（可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响）。</li>
</ul>
</li>
</ul>
<h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h2 id="3种集群模式"><a href="#3种集群模式" class="headerlink" title="3种集群模式"></a>3种集群模式</h2><p>主从模式<br>Sentinel 模式（哨兵模式）<br>Cluster 模式</p>
<h2 id="主从Master-Slave模式"><a href="#主从Master-Slave模式" class="headerlink" title="主从Master-Slave模式"></a>主从Master-Slave模式</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34596292/article/details/112646529">https://blog.csdn.net/qq_34596292/article/details/112646529</a></p>
</blockquote>
<p>Redis 的主从模式跟 mysql 主从复制原理差不多，在主从复制中，数据库分为两类：主数据库（master）和从数据库（slave）。</p>
<p>主从复制主要有如下特点：</p>
<ul>
<li>主数据库可以进行读写操作，从库只能进行读操作（可以配置从库支持读写操作，不建议）。</li>
<li>当主数据库的读写操作导致数据变化时会自动将数据同步给从数据库。</li>
<li>主从模式可以是一主多从，即一个 master 可以拥有多个 slave，但只能一从一主，即一个 slave 只能对应一个 master。</li>
<li>slave 挂了之后不会影响其它 slave 读和 master 读写，重启启动 slave 之后会自动从 master 同步数据过来。</li>
<li>master 挂了以后，不影响 slave 读，但 Redis 不再提供写服务，master 重启后 Redis 将重新对外提供写服务。</li>
<li>master 挂了以后，不会在 slave 节点中重新选一个 master。</li>
<li>master 节点在主从模式中唯一，若 master 挂掉，则 Redis 无法对外提供写服务。</li>
</ul>
<h2 id="主从不一致"><a href="#主从不一致" class="headerlink" title="主从不一致"></a>主从不一致</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。</p>
<blockquote>
<p>你有多个APP的会员账号，你在自己的网站上发布了腾讯视频、爱奇艺等等的账号密码（就是没有芒果TV的会员）。<br>你的网站：redis，你的电话：数据库。<br>甲每过十秒钟就查询你的网站，发现网站没有B站的会员后，给你打电话。这就是缓存穿透。</p>
</blockquote>
<ul>
<li>解决办法：</li>
</ul>
<ol>
<li>接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id&lt;&#x3D;0的直接拦截；</li>
<li>缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击。</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>一个很热门的数据，突然失效，大量请求到服务器数据库中。</p>
<blockquote>
<p>大家都喜欢看优酷上的《甄嬛传》，但是优酷会员突然到期了，大家在你的网站上看不到优酷的账号，纷纷向你打电话，这就是缓存击穿。</p>
</blockquote>
<ul>
<li>解决办法：设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员。</li>
</ul>
<h3 id="缓冲雪崩"><a href="#缓冲雪崩" class="headerlink" title="缓冲雪崩"></a>缓冲雪崩</h3><p>大量数据同一时间失效。</p>
<blockquote>
<p>你的各种会员突然同一时间都失效了，这就是缓存雪崩。</p>
</blockquote>
<ul>
<li>解决办法：</li>
</ul>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
</ol>
<h2 id="淘汰策略-6种"><a href="#淘汰策略-6种" class="headerlink" title="淘汰策略 6种"></a>淘汰策略 6种</h2><ul>
<li>volatile-lru： LRU算法，在设置过期时间的键中，选取一个最近最少使用的key淘汰掉。</li>
<li>volatile-ttl： 在设置了过期时间的键中，选取一个即将要过期的key淘汰。</li>
<li>volatile-random： 在设置了过期时间的键中，随机选取一个key淘汰。</li>
<li>allkeys-lru： 在所有键中，选取一个最近最少使用的key淘汰掉。</li>
<li>allkeys-random： 在所有键中，随机选取一个淘汰。</li>
<li>noeviction： 当内存到达阈值后，所有申请内存的操作都会报错。禁止驱逐数据（默认使用）。</li>
</ul>
<p>以上6种是让我们选出应该淘汰的键，那具体要怎么样进行删除？</p>
<blockquote>
<p>Redis中有3种删除过期键策略。</p>
</blockquote>
<h2 id="删除策略-3种"><a href="#删除策略-3种" class="headerlink" title="删除策略 3种"></a>删除策略 3种</h2><ul>
<li><p>定时删除：在设置键的过期时间的同时，设置一个定时器，当键过期了，定时器马上把该键删除。</p>
<blockquote>
<p>定时删除对内存来说是友好的，因为它可以及时清理过期键；但对CPU是不友好的，如果过期键太多，删除操作会消耗过多的资源。</p>
</blockquote>
</li>
<li><p>惰性删除：在键过期时，放任不管，如果后来有请求来查询该键，检测到该键已经过期了，此时才将这个键删除掉。</p>
<blockquote>
<p>惰性删除对CPU是友好的，因为只有在读取的时候检测到过期了才会将其删除。但对内存是不友好，如果过期键后续不被访问，那么这些过期键将积累在缓存中，对内存消耗是比较大的。</p>
</blockquote>
</li>
<li><p>定期删除：是定时删除和惰性删除的一个折中方案。每隔一段时间来删除过期键，可以根据实际场景自定义这个间隔时间，在CPU资源和内存资源上作出权衡。</p>
</li>
</ul>
<h2 id="在复制AOF文件时如何处理过期"><a href="#在复制AOF文件时如何处理过期" class="headerlink" title="在复制AOF文件时如何处理过期"></a>在复制AOF文件时如何处理过期</h2><p>为了获得正确的行为而不牺牲一致性,当一个key过期,DEL将会随着着AOF文字一起合成到所有附加的slaves。<br>在master实例中,这种方法是集中的,并且不存在一致性错误的机会。</p>
<p>然而,当slaves连接到master时,不会独立过期keys(会等到masteer执行DEL命令),他们任然会在数据集里面存在,所以当slave当选为master时淘汰keys会独立执行,然后成为rmaster。</p>
<h2 id="Redis缓存和MySQL不一致"><a href="#Redis缓存和MySQL不一致" class="headerlink" title="Redis缓存和MySQL不一致"></a>Redis缓存和MySQL不一致</h2><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。</p>
<h3 id="延时双删策略"><a href="#延时双删策略" class="headerlink" title="延时双删策略"></a>延时双删策略</h3><h3 id="删除缓存重试机制"><a href="#删除缓存重试机制" class="headerlink" title="删除缓存重试机制"></a>删除缓存重试机制</h3><h3 id="读取biglog异步删除缓存"><a href="#读取biglog异步删除缓存" class="headerlink" title="读取biglog异步删除缓存"></a>读取biglog异步删除缓存</h3><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><h2 id="缓存如何回收"><a href="#缓存如何回收" class="headerlink" title="缓存如何回收"></a>缓存如何回收</h2>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>hengqu4
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://hengqu4.github.io/2023/07/31/redis-knowledge/" title="Redis">https://hengqu4.github.io/2023/07/31/redis-knowledge/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
              <a href="/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 非关系型数据库</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/31/mysql-knowledge/" rel="prev" title="MySQL">
                  <i class="fa fa-chevron-left"></i> MySQL
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/08/15/lc-knowledge/" rel="next" title="刷题-复杂度">
                  刷题-复杂度 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">hengqu4</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":200,"position":"right","hOffset":20,"vOffset":20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat_2.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat_2.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hengqu4.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="Java知识库">
<meta property="og:url" content="https://hengqu4.github.io/2023/07/30/java-knowledge/index.html">
<meta property="og:site_name" content="Hengqu4">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hengqu4.github.io/2023/07/30/java-knowledge/hashmap.png">
<meta property="og:image" content="https://hengqu4.github.io/2023/07/30/java-knowledge/throw1.png">
<meta property="og:image" content="https://hengqu4.github.io/2023/07/30/java-knowledge/throw2.png">
<meta property="og:image" content="https://hengqu4.github.io/2023/07/30/java-knowledge/recommand.jpg">
<meta property="article:published_time" content="2023-07-30T13:36:24.000Z">
<meta property="article:modified_time" content="2023-08-18T08:49:56.301Z">
<meta property="article:author" content="hengqu4">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hengqu4.github.io/2023/07/30/java-knowledge/hashmap.png">


<link rel="canonical" href="https://hengqu4.github.io/2023/07/30/java-knowledge/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hengqu4.github.io/2023/07/30/java-knowledge/","path":"2023/07/30/java-knowledge/","title":"Java知识库"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java知识库 | Hengqu4</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hengqu4</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">The best time is now.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E3%80%81JRE%E3%80%81JVM%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.</span> <span class="nav-text">JDK、JRE、JVM关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK"><span class="nav-number">1.1.1.</span> <span class="nav-text">JDK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JRE"><span class="nav-number">1.1.2.</span> <span class="nav-text">JRE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM"><span class="nav-number">1.1.3.</span> <span class="nav-text">JVM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E3%80%81equals%E3%80%81hashCode"><span class="nav-number">1.2.</span> <span class="nav-text">&#x3D;&#x3D; 、equals、hashCode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-b"><span class="nav-number">1.2.1.</span> <span class="nav-text">a&#x3D;&#x3D;b</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-equals-b"><span class="nav-number">1.2.2.</span> <span class="nav-text">a.equals(b)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E6%AF%94%E8%BE%83"><span class="nav-number">1.2.3.</span> <span class="nav-text">String 比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-hashCode-b"><span class="nav-number">1.2.4.</span> <span class="nav-text">a.hashCode(b)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90"><span class="nav-number">1.3.</span> <span class="nav-text">hashCode()如何生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99"><span class="nav-number">1.4.</span> <span class="nav-text">重载、重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int%E3%80%81integer"><span class="nav-number">1.6.</span> <span class="nav-text">int、integer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E3%80%81Set%E3%80%81Map"><span class="nav-number">1.7.</span> <span class="nav-text">List、Set、Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E5%8E%9F%E7%90%86"><span class="nav-number">1.8.</span> <span class="nav-text">HashMap原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E3%80%81Hashtable"><span class="nav-number">1.9.</span> <span class="nav-text">HashMap、Hashtable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList%E3%80%81LinkedList"><span class="nav-number">1.10.</span> <span class="nav-text">ArrayList、LinkedList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder"><span class="nav-number">1.11.</span> <span class="nav-text">String、StringBuffer、StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.12.</span> <span class="nav-text">数据结构插入复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.13.</span> <span class="nav-text">接口、抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.14.</span> <span class="nav-text">Java异常机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E3%80%81%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="nav-number">1.15.</span> <span class="nav-text">受检异常、非受检异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.16.</span> <span class="nav-text">Java异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw%E3%80%81throws"><span class="nav-number">1.17.</span> <span class="nav-text">throw、throws</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8"><span class="nav-number">1.18.</span> <span class="nav-text">自定义异常如何应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB"><span class="nav-number">1.19.</span> <span class="nav-text">声明一个不会被继承的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.20.</span> <span class="nav-text">并发、并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="nav-number">1.21.</span> <span class="nav-text">进程、线程、协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8Bvs%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.21.1.</span> <span class="nav-text">进程vs线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8Bvs%E5%8D%8F%E7%A8%8B"><span class="nav-number">1.21.2.</span> <span class="nav-text">线程vs协程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">1.22.</span> <span class="nav-text">进程通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">1.23.</span> <span class="nav-text">线程通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">1.24.</span> <span class="nav-text">协程通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.25.</span> <span class="nav-text">java实现多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.26.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.26.1.</span> <span class="nav-text">数据库实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.26.2.</span> <span class="nav-text">缓存Redis实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.26.3.</span> <span class="nav-text">Zookeeper实现分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">1.27.</span> <span class="nav-text">synchronized同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">1.28.</span> <span class="nav-text">乐观锁、悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">1.28.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">1.28.2.</span> <span class="nav-text">悲观锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">1.29.</span> <span class="nav-text">自旋锁、互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.29.1.</span> <span class="nav-text">自旋锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8B%AC%E4%BA%AB%E9%94%81%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">1.30.</span> <span class="nav-text">独享锁、共享锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E3%80%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">1.31.</span> <span class="nav-text">公平锁、非公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8DJava%E6%AD%BB%E9%94%81"><span class="nav-number">1.32.</span> <span class="nav-text">避免Java死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-8-vs-7"><span class="nav-number">1.33.</span> <span class="nav-text">java 8 vs 7</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-11-vs-8"><span class="nav-number">1.34.</span> <span class="nav-text">java 11 vs 8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-17-vs-11"><span class="nav-number">1.35.</span> <span class="nav-text">java 17 vs 11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8C%82%E4%BA%86%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-TCP-%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%9C%A8%E5%90%97%EF%BC%9F"><span class="nav-number">1.36.</span> <span class="nav-text">服务端挂了，客户端的 TCP 连接还在吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC%E5%8D%8F%E8%AE%AE-vs-%E6%9C%AC%E5%9C%B0%E8%B0%83%E7%94%A8"><span class="nav-number">1.37.</span> <span class="nav-text">RPC协议 vs 本地调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC%E5%8D%8F%E8%AE%AE-vs-HTTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.38.</span> <span class="nav-text">RPC协议 vs HTTP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.39.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.39.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF"><span class="nav-number">1.39.2.</span> <span class="nav-text">场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%B1%9E%E4%BA%8EOSI%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="nav-number">1.40.</span> <span class="nav-text">序列化属于OSI哪一层？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E6%96%B9%E5%BC%8F"><span class="nav-number">1.41.</span> <span class="nav-text">序列化常见的协议&#x2F;方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.42.</span> <span class="nav-text">java序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK-%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">1.42.1.</span> <span class="nav-text">JDK 自带的序列化方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.42.1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Serializable-%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.42.1.2.</span> <span class="nav-text">Serializable 举例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#serialVersionUID"><span class="nav-number">1.42.1.3.</span> <span class="nav-text">serialVersionUID</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kryo"><span class="nav-number">1.42.2.</span> <span class="nav-text">Kryo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protobuf"><span class="nav-number">1.42.3.</span> <span class="nav-text">Protobuf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProtoStuff"><span class="nav-number">1.42.4.</span> <span class="nav-text">ProtoStuff</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hession"><span class="nav-number">1.42.5.</span> <span class="nav-text">hession</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.43.</span> <span class="nav-text">Java代理实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">1.44.</span> <span class="nav-text">推荐系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">1.45.</span> <span class="nav-text">高并发中的集合有哪些问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-number">2.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactory%E3%80%81ApplicationContext"><span class="nav-number">2.1.</span> <span class="nav-text">BeanFactory、ApplicationContext</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hengqu4"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">hengqu4</p>
  <div class="site-description" itemprop="description">Master of Software Engineering</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hengqu4" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hengqu4" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jxy2000910@gmail.com" title="E-Mail → mailto:jxy2000910@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hengqu4.github.io/2023/07/30/java-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="hengqu4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hengqu4">
      <meta itemprop="description" content="Master of Software Engineering">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java知识库 | Hengqu4">
      <meta itemprop="description" content=" ">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java知识库
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-30 21:36:24" itemprop="dateCreated datePublished" datetime="2023-07-30T21:36:24+08:00">2023-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-18 16:49:56" itemprop="dateModified" datetime="2023-08-18T16:49:56+08:00">2023-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description"> </div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="JDK、JRE、JVM关系"><a href="#JDK、JRE、JVM关系" class="headerlink" title="JDK、JRE、JVM关系"></a>JDK、JRE、JVM关系</h2><p>JDK包括JRE，JRE包括JVM。  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>JVM</td>
<td>Java虚拟机</td>
<td>执行java字节码的程序</td>
</tr>
<tr>
<td>JRE</td>
<td>包括了JVM、JVM工作所需要的类库</td>
<td>运行Java程序</td>
</tr>
<tr>
<td>JDK</td>
<td>Java标准开发包，包括Java编译器、Java运行时的环境、Java类库等等</td>
<td>编译Java源文件</td>
</tr>
</tbody></table>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>JDK(Java Development Kit) 安装完成后，目录下面有6个文件夹：<code>src类库源码压缩包</code>和<code>其他几个声明文件</code>。<br>其中，真正在运行java时起作用的 是以下四个文件夹：bin、include、lib、 jre。</p>
<ul>
<li>bin:  最主要的是编译器(javac.exe)</li>
<li>include:  java和JVM交互用的头文件</li>
<li>lib:  类库</li>
<li>jre:  java运行环境</li>
</ul>
<blockquote>
<p>注意：这里的bin、lib文件夹和jre里的bin、lib是 不同的。</p>
</blockquote>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>JRE（Java Runtime Environment）是指java运行环境。光有JVM还不能成class的 执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。<br>（jre里有运行.class的java.exe）</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM（Java Virtual Machine），即java虚拟机, java运行时的环境。<br>一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。<br>可运行的<code>.class</code>文件包（<code>jar</code>或者<code>war</code>），里面主要包含了jvm和java运行时基本类库（rt.jar）。rt.jar可以简单粗暴地理解为：它就是java源码编译成的jar包。<br><strong>Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</strong></p>
<h2 id="、equals、hashCode"><a href="#、equals、hashCode" class="headerlink" title="&#x3D;&#x3D; 、equals、hashCode"></a>&#x3D;&#x3D; 、equals、hashCode</h2><h3 id="a-b"><a href="#a-b" class="headerlink" title="a&#x3D;&#x3D;b"></a>a&#x3D;&#x3D;b</h3><blockquote>
<p>主要用于基本类型之间的比较（char、Boolean、byte、short、int、long、float、dobule），也可以用于比较对象。</p>
</blockquote>
<p>比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。  </p>
<ul>
<li>如果是基本技术类型，比如具体的阿拉伯数字，值相等则为true。如：int a&#x3D;10与long b&#x3D;10L与double c&#x3D;10.0都是相同的（为true），因为他们都指向地址为10的堆。  </li>
<li>如果是引用类型，比较的是引用地址。</li>
</ul>
<h3 id="a-equals-b"><a href="#a-equals-b" class="headerlink" title="a.equals(b)"></a>a.equals(b)</h3><blockquote>
<p>对象之间的比较（基本类型的包装器类型，string，自己定义的对象等）</p>
</blockquote>
<p>比较的是两个对象的内容是否相等。<br><strong>可以通过重写equals方法从而比较对象的内容是否相同，如果不重写那么和&#x3D;&#x3D;符号没有区别，都是比较的对象的引用是否指向同一个对象。</strong><br>“&#x3D;&#x3D;”比”equals”运行速度快,因为”&#x3D;&#x3D;”只是比较引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-比较"><a href="#String-比较" class="headerlink" title="String 比较"></a>String 比较</h3><p><strong>String类对equals进行了重写，所以对于String类型其equals比较的是内容而不是引用地址。</strong>  </p>
<p><code>String s=&quot;abce&quot;</code>是一种非常特殊的形式，和new有本质的区别。它是java中唯一不需要new就可以产生对象的途径。<br>以 <code>String s=&quot;abce&quot;;</code>形式赋值在java中叫直接量，它是在常量池中，而不是像new一样放在压缩堆中。  </p>
<p>这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有没有一个值为<code>&quot;abcd&quot;</code>的对象：</p>
<ul>
<li>如果有，就会把它赋给当前引用，即原来那个引用和现在这个引用指向了同一对象；</li>
<li>如果没有，则在常量池中新创建一个<code>&quot;abcd&quot;</code>，下一次如果有<code>String s1 = &quot;abcd&quot;</code>;又会将<code>s1</code>指向<code>&quot;abcd&quot;</code>这个对象。</li>
</ul>
<p>即以<code>String s=&quot;abce&quot;;</code>这种形式声明的字符串，只要值相等，任何多个引用都指向同一对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a为一个引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) &#123; </span><br><span class="line">   System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">   <span class="comment">// true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123; </span><br><span class="line">   System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">   <span class="comment">// false，非同一对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">   <span class="comment">// true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; </span><br><span class="line">   System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">   <span class="comment">// true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="a-hashCode-b"><a href="#a-hashCode-b" class="headerlink" title="a.hashCode(b)"></a>a.hashCode(b)</h3><p>hashCode()方法和equal()方法的作用一样，在Java里都是用来对比两个对象是否相等一致。  </p>
<p>Object类中的hashCode()方法：返回对象在内存中地址转换成的一个int值。<br>所以如果没有重写hashCode()方法，任何对象的hashCode()方法都是不相等的。  </p>
<ul>
<li>equal()相等的两个对象，他们的hashCode()一定相等。用equal()比较是绝对可靠的。</li>
<li>hashCode()相等的两个对象，他们的equal()不一定相等。用hashCode()比较不是绝对可靠的。</li>
</ul>
<blockquote>
<p>一般在覆盖equals()方法的同时也要覆盖hashCode()方法。<br>否则，就会违反Object.hashCode的通用约定，从而导致该类无法与所有基于散列值(hash)集合类(HashMap、HashSet和Hashtable)结合在一起正常运行。</p>
</blockquote>
<p><strong>为什么还需要hashCode()呢？</strong></p>
<blockquote>
<p>因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。  </p>
</blockquote>
<p><strong>为什么还需要equals()呢？</strong></p>
<blockquote>
<p>因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。</p>
</blockquote>
<h2 id="hashCode-如何生成"><a href="#hashCode-如何生成" class="headerlink" title="hashCode()如何生成"></a>hashCode()如何生成</h2><blockquote>
<p>【为了彻底搞懂 hashCode，我钻了一下 JDK 的源码】HTTPs:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6994738336350863367<br>【java中常常提起的hashCode到底是个啥?】HTTPs:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;188736282</p>
</blockquote>
<p>hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的。<br>所有的类都会默认继承自 Object 类，Object 类中就包含了 hashCode() 方法，该方法会返回一个 int 类型的值。</p>
<blockquote>
<p>由于 hashCode() 方法是一个本地方法（native 关键字修饰的方法，用 C&#x2F;C++ 语言实现，由 Java 调用），意味着 <strong>Object 类中并没有给出具体的实现</strong>。具体的实现可以参考 <code>jdk/src/hotspot/share/runtime/synchronizer.cpp</code>（源码可以到 GitHub 上 OpenJDK 的仓库中下载）。<code>get_next_hash()</code> 方法会根据 hashCode 的取值来决定采用哪一种哈希值的生成策略。</p>
</blockquote>
<ul>
<li><code>hashCode == 0</code>，调用操作系统 OS 的 random() 方法返回随机数。</li>
<li><code>hashCode == 1</code>，将对象的内存地址，做移位运算后，与一个随机数进行异或得到结果。</li>
<li><code>hashCode == 2</code>，返回 1，用于某些情况下的测试。</li>
<li><code>hashCode == 3</code>，返回一个自增序列的当前值。从 0 开始计算哈希值，不是线程安全的，多个线程可能会得到相同的哈希值。</li>
<li><code>hashCode == 4</code>，返回当前对象的内存地址。</li>
<li><code>hashCode == 5</code>，支持多线程，使用了 Marsaglia 的 xor-shift 算法产生伪随机数。简单来说，通过和当前线程有关的<strong>一个随机数 + 三个确定值 + xorshift算法</strong>得到的一个随机数，可以当作真随机数来使用。（JDK8 的hashCode的默认计算方法就是这个）</li>
</ul>
<h2 id="重载、重写"><a href="#重载、重写" class="headerlink" title="重载、重写"></a>重载、重写</h2><table>
<thead>
<tr>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>体现一个类中多态性</td>
<td>体现父类与子类之间多态性</td>
</tr>
<tr>
<td>在一个类中定义了多个同名的方法，它们参数列表不同，则称为方法的重载</td>
<td>在子类中定义某方法与其父类有相同的名称和参数，子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。</td>
</tr>
<tr>
<td>同一个类中不同的函数使用相同的函数名，但是函数的参数个数或类型不同。可以有不同的返回类型;可以有不同的访问修饰符;可以抛出不同的异常。<strong>调用的时候根据函数的参数来区别不同的函数</strong>。</td>
<td><strong>函数名和参数与父类一样</strong>，子类与父类函数体内容不一样。<strong>子类返回的类型必须与父类保持一致</strong>；子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public &gt; protected &gt; default &gt; private）；子类重写方法一定不能抛出新的检查异常或者比被父类方法申明更加宽泛的检查型异常。</td>
</tr>
</tbody></table>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>（1）基本数据类型，分为boolean、byte、int、char、long、short、double、float；<br>（2）引用数据类型 ，分为数组、类、接口。</p>
<h2 id="int、integer"><a href="#int、integer" class="headerlink" title="int、integer"></a>int、integer</h2><p>为了编程的方便还是引入了基本数据类型，但是<strong>为了能够将这些基本数据类型当成对象操作</strong>，Java为每 一个基本数据类型都引入了<strong>对应的包装类型</strong>（wrapper class），从Java 5开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p>
<blockquote>
<p>自动装箱就是将基本数据类型直接变成Integer包装类。自动拆箱和装箱动作相反，即将对象中的数据变回基本数据类型。自动拆箱和装箱的好处就是基本类型和引用类型可以直接运算。</p>
</blockquote>
<ul>
<li>Integer是int的包装类；int是基本数据类型；</li>
<li>Integer变量必须实例化后才能使用；int变量不需要；</li>
<li>Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；</li>
<li>Integer的默认值是null；int的默认值是0。</li>
</ul>
<p>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。<br>因为<strong>非 new 生成的 Integer 变量</strong>指向的是 java 常量池中的对象，而 <code>new Integer()</code> 生成的变量指向堆中新建的对象，两者在内存中的地址不同。所以输出为 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>


<p>两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。</p>
<p>java在编译<code>Integer i = 100 ;</code>时，会翻译成为<code>Integer i = Integer.valueOf(100)</code>。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，<code>Integer i = 127</code>时，会将127这个Integer对象进行缓存，下次再写<code>Integer j = 127</code>时，就会直接从缓存中取，就不会new了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>封装类类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<h2 id="List、Set、Map"><a href="#List、Set、Map" class="headerlink" title="List、Set、Map"></a>List、Set、Map</h2><table>
<thead>
<tr>
<th>List</th>
<th>Set</th>
<th>Map</th>
</tr>
</thead>
<tbody><tr>
<td>存储单列的数据集合，继承自Collection接口</td>
<td>同List</td>
<td>存储键值对这样的双列数据的集合，独立接口</td>
</tr>
<tr>
<td>有序集合</td>
<td>无序集合</td>
<td>无序集合</td>
</tr>
<tr>
<td>允许重复元素</td>
<td>不允许重复元素</td>
<td>键对象必须是唯一的</td>
</tr>
<tr>
<td>允许任意数量的空值</td>
<td>最多只能有一个空值</td>
<td>键是不允许重复的，值是可以重复</td>
</tr>
<tr>
<td>实现：ArrayList， LinkedList</td>
<td>HashSet、LinkedHashSet、TreeSet</td>
<td>HashMap、LinkedHashMap、Hashtable 、 TreeMap</td>
</tr>
</tbody></table>
<h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><blockquote>
<p>【Java 8系列之重新认识HashMap】HTTPs:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;21673805</p>
</blockquote>
<p>HashMap由数组+链表组成的。数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<ul>
<li>如果定位到的数组位置不含链表（当前entry的next指向null），那么对于查找，添加等操作很快，仅需一次寻址即可；</li>
<li>如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)。<blockquote>
<p>首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。</p>
</blockquote>
</li>
</ul>
<p>所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p>
<p>即使Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。</p>
<p>在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。<br><strong>当链表长度太长（默认超过8）时，链表就转换为红黑树</strong>，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。</p>
<img src="/2023/07/30/java-knowledge/hashmap.png" width="50%">
<!-- ![page-hashmap]( "HashMap结构") -->

<h2 id="HashMap、Hashtable"><a href="#HashMap、Hashtable" class="headerlink" title="HashMap、Hashtable"></a>HashMap、Hashtable</h2><p>Map接口下面比较重要的两个实现子类</p>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>Hashtable</th>
</tr>
</thead>
<tbody><tr>
<td>非线程同步（多线程时候可以有一系列问题）</td>
<td>线程同步（数据不会乱，不管有几个线程处理都没有问题。它的方法有Synchronized关键字）</td>
</tr>
<tr>
<td>效率高</td>
<td>效率低</td>
</tr>
<tr>
<td>允许&lt;键,值&gt;有空值。但是只能有一个key为null值，可以有多个value为空值</td>
<td>不允许&lt;键,值&gt;有空值。key和value都不允许为空值</td>
</tr>
<tr>
<td>HashMap中hash数组的默认大小是16,增长</td>
<td></td>
</tr>
<tr>
<td>方式是2的指数倍</td>
<td>Hashtable中hash数组的默认大小是11,增加方式的old*2+1</td>
</tr>
<tr>
<td>HashMap继承自AbstractMap类（是接口相同，都是Map，但父类不同）</td>
<td>Hashtable继承自Dictionary类</td>
</tr>
<tr>
<td>使用Iterator</td>
<td>使用Enumeration（现在也支持Iterator了）</td>
</tr>
</tbody></table>
<h2 id="ArrayList、LinkedList"><a href="#ArrayList、LinkedList" class="headerlink" title="ArrayList、LinkedList"></a>ArrayList、LinkedList</h2><table>
<thead>
<tr>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>底层是数组</td>
<td>底层是链表</td>
</tr>
<tr>
<td>可以随机访问，复杂度O(1)</td>
<td>查找元素复杂度O(n)</td>
</tr>
<tr>
<td>插入&#x2F;删除复杂度O(n)</td>
<td>插入&#x2F;删除复杂度O(1)</td>
</tr>
</tbody></table>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><table>
<thead>
<tr>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>字符串常量，一旦被创建后不可更改（更改时相当于创建新对象并把旧的回收）</td>
<td>字符串变量，对象可以更改。修改value（数组地址）和count（数组长度），如果数组数量不够了就进行扩容，并把value指向新的数组地址</td>
<td>同StringBuffer</td>
</tr>
<tr>
<td>线程安全，因为是不可变序列</td>
<td>线程安全，StringBuffer许多方法带有Synchronized关键字</td>
<td>线程不安全，没有Synchronized关键字（在单线程情况下使用的，效率最高）</td>
</tr>
<tr>
<td>运行速度最慢</td>
<td>运行速度中间</td>
<td>运行速度最快</td>
</tr>
<tr>
<td>适用于字符串有少量操作时</td>
<td>适用于多线程，在字符缓存区有大量插入更改操作时</td>
<td>适用于单线程，在字符缓存区有大量插入更改操作时</td>
</tr>
</tbody></table>
<h2 id="数据结构插入复杂度"><a href="#数据结构插入复杂度" class="headerlink" title="数据结构插入复杂度"></a>数据结构插入复杂度</h2><table>
<thead>
<tr>
<th>数据结构</th>
<th>查找</th>
<th>插入</th>
<th>删除</th>
</tr>
</thead>
<tbody><tr>
<td>有序数组</td>
<td>O(lgn)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>数组ArrayList</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>链表LinkedList</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>红黑二叉树TreeMap</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
</tr>
<tr>
<td>哈希表HashMap (hash碰撞情况都是O(lgn))</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="接口、抽象类"><a href="#接口、抽象类" class="headerlink" title="接口、抽象类"></a>接口、抽象类</h2><p><strong>接口</strong></p>
<ul>
<li>供别人调用的方法或者函数。接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final变量，用 private 修饰会报编译错误），而方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，<strong>接口中的方法必须都是抽象方法</strong>。</li>
</ul>
<p><strong>抽象类</strong></p>
<ul>
<li>对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为 abstract 方法，此时这个类也就成为 abstract 类。</li>
</ul>
<blockquote>
<p>相同点：<br>（1）都不能被实例化<br>（2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p>
</blockquote>
<table>
<thead>
<tr>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>interface关键字</td>
<td>abstract关键字</td>
</tr>
<tr>
<td>实现接口的关键字为implements</td>
<td>继承抽象类的关键字为extends</td>
</tr>
<tr>
<td>一个类可以实现多个接口</td>
<td>一个类只能继承一个抽象类</td>
</tr>
<tr>
<td>接口只有定义，不能有方法的实现</td>
<td>抽象类可以有定义与实现，方法可在抽象类中实现</td>
</tr>
<tr>
<td>强调特定功能的实现</td>
<td>抽象类强调所属关系</td>
</tr>
<tr>
<td>接口中不能含有静态代码块以及静态方法</td>
<td>抽象类可以有静态代码块和静态方法</td>
</tr>
</tbody></table>
<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p>
<p>举个简单的例子: </p>
<blockquote>
<p>飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。<br>可以将飞机设计为一个类 <code>Airplane</code>，将鸟设计为一个类 <code>Bird</code>，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。<br>此时可以将 飞行 设计为一个接口<code>Fly</code>，包含方法<code>fly( )</code>，然后<code>Airplane</code>和<code>Bird</code>分别根据自己的需要实现<code>Fly</code>这个接口。<br>然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承<code>Airplane</code>即可，对于鸟也是类似的，不同种类的鸟直接继承<code>Bird</code>类即可。</p>
</blockquote>
<p>从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<h2 id="Java异常机制"><a href="#Java异常机制" class="headerlink" title="Java异常机制"></a>Java异常机制</h2><blockquote>
<p>【java异常面试题（2021最新版）】HTTPs:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1819397</p>
</blockquote>
<p>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。</p>
<p>异常能清晰的回答what, where, why这3个问题：</p>
<ul>
<li>异常类型回答了“什么”被抛出，</li>
<li>*异常堆栈跟踪回答了“在哪”抛出，</li>
<li>异常信息回答了“为什么”会抛出。</li>
</ul>
<p>Java异常架构<br><img src="/2023/07/30/java-knowledge/throw1.png" alt="page-throw1" title=" Java异常架构"></p>
<h2 id="受检异常、非受检异常"><a href="#受检异常、非受检异常" class="headerlink" title="受检异常、非受检异常"></a>受检异常、非受检异常</h2><table>
<thead>
<tr>
<th>受检异常</th>
<th>非受检异常</th>
</tr>
</thead>
<tbody><tr>
<td>也叫编译时异常</td>
<td>也叫运行时异常</td>
</tr>
<tr>
<td>Java 编译器会检查它</td>
<td>Java 编译器不会检查它</td>
</tr>
<tr>
<td><code>Exception</code> 中除 <code>RuntimeException</code> 及其子类之外的异常。</td>
<td><code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。</td>
</tr>
<tr>
<td>如果程序中出现此类异常，要么通过<code>throws</code>进行声明抛出，要么通过<code>try-catch</code>进行捕获处理，否则不能通过编译。</td>
<td>当程序中可能出现这类异常时，哪怕没有通过<code>throws</code>声明抛出它 或者 没用<code>try-catch</code>语句捕获它，也还会编译通过。</td>
</tr>
<tr>
<td>该异常我们必须手动在代码里添加捕获语句来处理该异常</td>
<td><code>RuntimeException</code> 异常会由 Java 虚拟机自动抛出并自动捕获，此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</td>
</tr>
</tbody></table>
<h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><ol>
<li>声明异常<br>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <code>throws</code> 关键字声明可能会抛出的异常。 <blockquote>
<p>非检查异常（<code>Error</code>、<code>RuntimeException</code> 或它们的子类）不可使用 <code>throws</code> 关键字来声明要抛出的异常。<br>一个方法出现编译时异常，就需要 <code>try-catch</code>&#x2F; <code>throws </code>处理，否则会导致编译错误。 </p>
</blockquote>
</li>
<li>抛出异常<br>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。<br><code>throw</code>关键字作用是在方法内部抛出一个 <code>Throwable</code> 类型的异常。任何Java代码都可以通过<code>throw</code>语句抛出异常。</li>
<li>捕获异常<br>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过<code>try…catch…</code>的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</li>
</ol>
<p>可以根据下图来选择是捕获异常、声明异常还是抛出异常:<br><img src="/2023/07/30/java-knowledge/throw2.png" alt="page-throw2" title="如何选择异常类型"></p>
<h2 id="throw、throws"><a href="#throw、throws" class="headerlink" title="throw、throws"></a>throw、throws</h2><table>
<thead>
<tr>
<th>throw</th>
<th>throws</th>
</tr>
</thead>
<tbody><tr>
<td>在方法内部</td>
<td>在方法的声明处</td>
</tr>
<tr>
<td>throw+异常对象(检查异常,运行时异常)</td>
<td>throws+异常的类型(可以多个类型,用,拼接)。</td>
</tr>
<tr>
<td><code>throw new RuntimeException除数不能为0&quot;);</code></td>
<td><code>private static void readFile(String filePath) throws IOException</code></td>
</tr>
<tr>
<td>只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</td>
<td>可以抛出多个异常，用来标识该方法可能抛出的异常列表</td>
</tr>
<tr>
<td>异常出现的源头,制造异常。</td>
<td>在方法的声明处,告诉方法的调用者,这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理，要么自己处理要么再继续向外抛出异常</td>
</tr>
</tbody></table>
<h2 id="自定义异常如何应用"><a href="#自定义异常如何应用" class="headerlink" title="自定义异常如何应用"></a>自定义异常如何应用</h2><p>Java虽然提供了丰富的异常处理类,但是在项目中还会经常使用自定义异常,其主要原因是Java提供的异常类在某些情况下还是不能满足实际需求。</p>
<p>例如以下情况:</p>
<ol>
<li>系统中有些错误是符合Java语法,但不符合业务逻辑。</li>
<li>在分层的软件结构中,通常是在表现层统一对系统其他层次的异常进行捕获处理。</li>
</ol>
<h2 id="声明一个不会被继承的类"><a href="#声明一个不会被继承的类" class="headerlink" title="声明一个不会被继承的类"></a>声明一个不会被继承的类</h2><p>如果一个类被final修饰,此类不可以有子类,不能被其它类继承,如果一一个中的所有方法都没有重写的需要,当前类没有子类也罢,就可<br>以使用final修饰类。<br><strong>场景</strong><br>Math类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// final 关键字，Math不能被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器Math()是private的，相当于Math在外界就不能构造对象了</span></span><br><span class="line">    <span class="comment">// 那么里面的方法就调不到了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Math</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 因此这里，每个方法前都有个static</span></span><br><span class="line">    <span class="comment">// static：可以通过 类名.属性名、类名.方法名 来调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Math.double</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">E</span> <span class="operator">=</span> <span class="number">2.7182818284590452354</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Math.sin(6)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StrictMath.sin(a); <span class="comment">// default impl. delegates to StrictMath</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;      </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h2><p>并发和并行虽然都说是”多个进程同时运行”，但是它们的”同时”不是一个概念。</p>
<ul>
<li>并行的”同时”是同一时刻可以多个进程在运行(处于running)。</li>
<li>并发的”同时”是经过上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象。</li>
</ul>
<p>当程序中写下<strong>多进程或多线程代码</strong>时，这意味着的是<strong>并发</strong>而不是并行。</p>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><ul>
<li>进程：进程就是程序的一次执行过程，程序是静态的，它作为系统中的一种资源是永远存在的。而进程是动态的，它是动态的产生，变化和消亡的，拥有其自己的生命周期。</li>
<li>线程：线程是进程的一个执行单元。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</li>
<li>协程：一个线程也可以拥有多个协程，是一种比线程更加轻量级的存在。</li>
</ul>
<h3 id="进程vs线程"><a href="#进程vs线程" class="headerlink" title="进程vs线程"></a>进程vs线程</h3><table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>不是基本单位</td>
<td>线程是处理器调度的基本单位。</td>
</tr>
<tr>
<td>均可并发执行</td>
<td>均可并发执行</td>
</tr>
<tr>
<td>进程之间是独立的地址空间</td>
<td>线程共享本进程的地址空间</td>
</tr>
<tr>
<td>进程之间的资源是独立的，能很好的进行资源管理</td>
<td>线程共享本进程的资源如内存、I&#x2F;O、cpu等</td>
</tr>
<tr>
<td>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</td>
<td>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</td>
</tr>
</tbody></table>
<h3 id="线程vs协程"><a href="#线程vs协程" class="headerlink" title="线程vs协程"></a>线程vs协程</h3><table>
<thead>
<tr>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>切换受系统控制</td>
<td>切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</td>
</tr>
<tr>
<td>cpu操作多</td>
<td>非cpu操作（比如I&#x2F;O操作）频繁时</td>
</tr>
</tbody></table>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li><strong>管道</strong>( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<blockquote>
<p>有名管道 (named pipe) ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
</blockquote>
</li>
<li><strong>信号量</strong>(semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>消息队列</strong>( message queue ) ：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>共享内存</strong>(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li><strong>套接字</strong>(socket ) ：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</li>
</ul>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><blockquote>
<p>实际上只有进程间需要通信。<br>同一进程的线程共享地址空间，没有通信的必要，但要做好同步&#x2F;互斥,保护共享的全局变量。</p>
</blockquote>
<ul>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
<h2 id="协程通信"><a href="#协程通信" class="headerlink" title="协程通信"></a>协程通信</h2><h2 id="java实现多线程"><a href="#java实现多线程" class="headerlink" title="java实现多线程"></a>java实现多线程</h2><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuqingzheng/p/11080501.html">HTTPs://www.cnblogs.com/liuqingzheng/p/11080501.html</a></p>
</blockquote>
<h3 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h3><h3 id="缓存Redis实现分布式锁"><a href="#缓存Redis实现分布式锁" class="headerlink" title="缓存Redis实现分布式锁"></a>缓存Redis实现分布式锁</h3><h3 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h3><h2 id="synchronized同步锁"><a href="#synchronized同步锁" class="headerlink" title="synchronized同步锁"></a>synchronized同步锁</h2><h2 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。<br>因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p>
<blockquote>
<p>实现方式：CAS机制、版本号机制</p>
</blockquote>
<p><strong>CAS</strong><br>CAS操作包括了3个操作数：</p>
<ol>
<li>需要读写的内存位置(V)</li>
<li>进行比较的预期值(E)</li>
<li>拟写入的新值(U)</li>
</ol>
<p>只有该变量当前的内存值V与预期值E相同时，才会将新值U写入内存完成变量修改，否则什么都不做。</p>
<p>下面是通过CAS修改变量数据的示例，CAS通过该变量的地址即可获取该变量当前的内存值V。<br>当本轮CAS操作失败后，会重新读取该变量内存中最新的值并重新计算新值，直到其CAS操作修改变量成功为止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="number">1.</span> 读取变量值，记为E。用于写入修改时，判断该变量是否被修改</span><br><span class="line">    <span class="number">2.</span> 使用读到的变量值E，计算该变量的新值,记为U</span><br><span class="line">&#125; <span class="keyword">while</span>( !CAS(变量内存地址，E，U) )</span><br></pre></td></tr></table></figure>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。<br>因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</p>
<blockquote>
<p>比如Java里面的synchronized关键字的实现就是悲观锁。<br>实现方式：就是加锁。既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）</p>
</blockquote>
<h2 id="自旋锁、互斥锁"><a href="#自旋锁、互斥锁" class="headerlink" title="自旋锁、互斥锁"></a>自旋锁、互斥锁</h2><p>由于在多处理器环境中某些资源的有限性，有时需要互斥访问(mutual exclusion)，这时候就需要引入锁的概念，只有获取了锁的线程才能够对资源进行访问，由于多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取到锁。<br>那么就面临一个问题，那么<strong>没有获取到锁的线程应该怎么办</strong>？</p>
<p>通常有两种处理方式：</p>
<ol>
<li>没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做<strong>自旋锁</strong>，它不用将线程阻塞起来(NON-BLOCKING)；</li>
<li>把自己阻塞起来，等待重新调度请求，这种叫做<strong>互斥锁</strong>。</li>
</ol>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。</p>
<p>因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。<br>由于这个原因，<strong>操作系统的内核经常使用自旋锁。</strong></p>
<p><strong>为什么设置自旋时间</strong><br>但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 OS 调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。</p>
<p>解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。</p>
<p>自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。</p>
<p>因此自旋的周期选的额外重要！JDK在1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是<strong>由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定</strong>，基本认为一个线程上下文切换的时间是最佳的一个时间。</p>
<p><strong>自旋锁场景</strong><br>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗。</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。</p>
<h2 id="独享锁、共享锁"><a href="#独享锁、共享锁" class="headerlink" title="独享锁、共享锁"></a>独享锁、共享锁</h2><p>两种锁只是一种概念</p>
<p>独享锁：该锁一次只能被一个线程所持有<br>共享锁：该锁可以被多个线程所持有</p>
<blockquote>
<p>synchronized是独享锁；<br>可重入锁ReentrantLock是独享锁；<br>读写锁ReentrantReadWriteLock中的 读锁ReadLock是共享锁，写锁WriteLock是独享锁。<br>独享锁与共享锁通过AQS(AbstractQueuedSynchronizer)来实现的，通过实现不同的方法，来实现独享或者共享。</p>
</blockquote>
<h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><p>公平锁：多个线程相互竞争时要排队，多个线程按照申请锁的顺序来获取锁。</p>
<p>非公平锁：多个线程相互竞争时，先尝试插队，插队失败再排队，比如：synchronized、ReentrantLock</p>
<h2 id="避免Java死锁"><a href="#避免Java死锁" class="headerlink" title="避免Java死锁"></a>避免Java死锁</h2><h2 id="java-8-vs-7"><a href="#java-8-vs-7" class="headerlink" title="java 8 vs 7"></a>java 8 vs 7</h2><ul>
<li>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>
<li>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>
<li>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li>Date Time API − 加强对日期与时间的处理。</li>
<li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h2 id="java-11-vs-8"><a href="#java-11-vs-8" class="headerlink" title="java 11 vs 8"></a>java 11 vs 8</h2><ul>
<li>局部变量类型推断，Java 10 引入了一个新的语言关键字 var，编译器从变量的赋值中推断出正确的类型。<ul>
<li>结合使用 final 和 var 可以禁止用另一个值对变量重新赋值。</li>
<li>当编译器不能推断出变量的正确类型时，也不允许使用var，会导致编译器错误。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Cannot infer type:</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="type">var</span> <span class="variable">nothing</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">lambda</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Pity!&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">method</span> <span class="operator">=</span> <span class="built_in">this</span>::someMethod;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>HTTPClient：新的 HTTPClient 既可以同步使用，也可以异步使用。<ul>
<li>同步请求阻塞当前线程，直到响应可用为止。</li>
<li>请求也可以异步执行。调用 sendAsync 不会阻塞当前线程，而是返回一个CompletableFuture 来构建异步操作管道。</li>
</ul>
</li>
<li>数据流 Streams 加了三个新方法。流是在 Java 8 中引入的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.ofNullable 从单个元素构造流</span></span><br><span class="line">Stream.ofNullable(<span class="literal">null</span>)</span><br><span class="line">    .count()   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dropWhile 和 takeWhile 方法都接受一个谓词来决定从流中放弃或选用哪些元素</span></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    .dropWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList());  <span class="comment">// [3, 2, 1]</span></span><br><span class="line"></span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    .takeWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList());  <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></li>
<li>String新增方法，用于修剪 trimming 或检查 checking 空白，以及将字符串转化为流。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; &quot;</span>.isBlank();       <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot; Foo Bar &quot;</span>.strip(); <span class="comment">// &quot;Foo Bar&quot;</span></span><br><span class="line"><span class="string">&quot; Foo Bar &quot;</span>.stripTrailing();  <span class="comment">// &quot; Foo Bar&quot;</span></span><br><span class="line"><span class="string">&quot; Foo Bar &quot;</span>.stripLeading();   <span class="comment">// &quot;Foo Bar &quot;</span></span><br><span class="line"><span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>);    <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line"><span class="string">&quot;A\nB\nC&quot;</span>.lines().count();    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="java-17-vs-11"><a href="#java-17-vs-11" class="headerlink" title="java 17 vs 11"></a>java 17 vs 11</h2><h2 id="服务端挂了，客户端的-TCP-连接还在吗？"><a href="#服务端挂了，客户端的-TCP-连接还在吗？" class="headerlink" title="服务端挂了，客户端的 TCP 连接还在吗？"></a>服务端挂了，客户端的 TCP 连接还在吗？</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/561756264">HTTPs://zhuanlan.zhihu.com/p/561756264</a></p>
</blockquote>
<ul>
<li>如果客户端会发送数据，由于服务端已经不存在，客户端的数据报文会超时重传，当重传次数达到一定阈值后，会断开 TCP 连接；</li>
<li>如果客户端一直不会发送数据，再看客户端有没有开启 TCP keepalive 机制？<ul>
<li>如果有开启，客户端在一段时间后，检测到服务端的 TCP 连接已经不存在，则会断开自身的 TCP 连接；</li>
<li>如果没有开启，客户端的 TCP 连接会一直存在，并不会断开。</li>
</ul>
</li>
</ul>
<h2 id="RPC协议-vs-本地调用"><a href="#RPC协议-vs-本地调用" class="headerlink" title="RPC协议 vs 本地调用"></a>RPC协议 vs 本地调用</h2><p>RPC协议的主要目的：做到不同服务间调用方法像同一服务间调用本地方法一样。</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>本地调用</th>
<th>RPC</th>
</tr>
</thead>
<tbody><tr>
<td>调用 ID 和函数的映射</td>
<td>进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。而函数名的本质就是一个函数指针，可以看成函数在内存中的地址。比如，调用函数 f()，编译器会帮我们找到函数 f() 相应的内存地址</td>
<td>RPC 中，只通过函数名是不行的，因为不同进程的地址空间是不一样的。所有的函数必须要有一个调用 ID 来唯一标识。<code> 1.</code> 一个机器上运行的进程在做远程过程调用时，必须附上这个调用 ID。<code>2.</code>在通信的两台机器间，分别维护一个函数与调用 ID 的映射表。两台机器维护的表中，相同的函数对应的调用 ID 必须保持一致。 <code>eg. </code>当一台机器 A 上运行的进程 P 需要远程调用时，它就先查一下机器 A 维护的映射表，找出对应的调用 ID，然后把它传到另一台机器 B 上，机器 B 通过查看它维护的映射表，从而确定进程 P 需要调用的函数，然后执行对应的代码，最后将执行结果返回到进程 P。</td>
</tr>
<tr>
<td>序列化和反序列化</td>
<td>进程之间共享内存等，因此我们只需要把参数压到栈里，然后进程自己去栈里读取</td>
<td>在 RPC 中，两个进程分布在不同的机器上，使用的是不同机器的内存，因此不可能通过内存来传递参数。网络协议传输的内容是二进制流，这就需要调用方把参数先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式。这个过程，就叫作序列化和反序列化。被调用方返回的结果也需要有序列化和反序列化的过程，不然调用方无法获取到结果。</td>
</tr>
</tbody></table>
<h2 id="RPC协议-vs-HTTP协议"><a href="#RPC协议-vs-HTTP协议" class="headerlink" title="RPC协议 vs HTTP协议"></a>RPC协议 vs HTTP协议</h2><p><code>HTTP协议</code>和<code>基于RPC协议实现的RPC框架</code>都能实现跨网络节点之间的一些服务通信，底层都是TCP协议作为通信基础。</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>HTTP</th>
<th>RPC</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>应用层的超文本传输协议，主要用在网页端和服务端的传输上</td>
<td>远程过程调用，用于实现不同计算机之间应用之间的数据通信，屏蔽了通信的底层复杂度，让开发者像调用本地服务一样去完成远程服务的调用</td>
</tr>
<tr>
<td>实现</td>
<td>已经成熟的协议，定义了通信报文的格式，比如Request Body、Request Header、Response Body、Response Header</td>
<td>只是通信协议的规范，没有具体的实现。按照RPC协议实现的通信框架，才是RPC协议的具体实现，比如Dubbo、gRPC。可以自定义报文通信的一些规范、自定义序列化方式、自定义网络通信协议的类型。</td>
</tr>
</tbody></table>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>序列化：把对象转化为字节序列过程称为序列化。便于网络运输和传播，也方便持久化存储到磁盘，避免程序运行结束后对象就从内存里消失。</li>
<li>反序列化：把字节序列还原为对象的过程称为反序列化。</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行序列化。</li>
<li>将对象存储到Redis时需要用到序列化，将对象从Redis中读取出来需要反序列化。</li>
</ol>
<h2 id="序列化属于OSI哪一层？"><a href="#序列化属于OSI哪一层？" class="headerlink" title="序列化属于OSI哪一层？"></a>序列化属于OSI哪一层？</h2><p>OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流量转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>
<p>OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层。</p>
<p>所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<h2 id="序列化常见的协议-方式"><a href="#序列化常见的协议-方式" class="headerlink" title="序列化常见的协议&#x2F;方式"></a>序列化常见的协议&#x2F;方式</h2><ul>
<li><code>JDK</code> 自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 <code>hessian</code>、<code>kyro</code>、<code>protostuf</code>。<blockquote>
<p>上述均属于基于二进制的序列化协议。具体介绍详见【java序列化】。</p>
</blockquote>
</li>
<li><code>JSON</code> 和 <code>XML</code> 这种属于文本类序列化方式，可读性比较好，但是性能较差，一般不会选择。</li>
</ul>
<h2 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化"></a>java序列化</h2><h3 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>要实现下面两个接口之一，2选1</p>
<ol>
<li>选择实现 Serializable 接口。</li>
<li>选择实现 Externalizable 接口。</li>
</ol>
<table>
<thead>
<tr>
<th>Serializable</th>
<th>Externalizable</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>是Serializable接口的子类</td>
</tr>
<tr>
<td>默认序列化所有属性，不想序列化的字段可以使用transient修饰。</td>
<td>要实现的<code>writeExternal()</code>和<code>readExternal()</code> 方法，用来决定如何序列化和反序列化。</td>
</tr>
</tbody></table>
<ul>
<li>被static修饰的字段是不会被序列化的</li>
<li>被transient修饰符修饰的字段也是不会被序列化的</li>
</ul>
<h4 id="Serializable-举例"><a href="#Serializable-举例" class="headerlink" title="Serializable 举例"></a>Serializable 举例</h4><p>假如我们要对Student类对象序列化到一个名为student.txt的文本文件中，然后再通过文本文件反序列化成Student类对象</p>
<ol>
<li><p>Student类定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student:&quot;</span> + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;name = &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;age = &quot;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27;\n&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;score = &quot;</span> + <span class="built_in">this</span>.score + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;CodeSheep&quot;</span>);</span><br><span class="line">    student.setAge( <span class="number">18</span> );</span><br><span class="line">    student.setScore( <span class="number">1000</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    objectOutputStream.writeObject( student );</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;序列化成功！已经生成student.txt文件&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;==============================================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deserialize</span><span class="params">(  )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>( <span class="keyword">new</span> <span class="title class_">FileInputStream</span>( <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;student.txt&quot;</span>) ) );</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化结果为：&quot;</span>);</span><br><span class="line">    System.out.println( student );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果【控制台打印】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">序列化成功！已经生成student.txt文件</span><br><span class="line">==============================================</span><br><span class="line">反序列化结果为：</span><br><span class="line">Student:</span><br><span class="line">name = CodeSheep</span><br><span class="line">age = 18</span><br><span class="line">score = 1000</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h4><p><code>serialVersionUID</code>是序列化前后的唯一标识符。</p>
<p>如果没有人为显式定义过<code>serialVersionUID</code>，那编译器会为它自动声明一个。</p>
<p><code>serialVersionUID</code>序列化ID，可以看成是序列化和反序列化过程中的“暗号”，在反序列化时，JVM会把字节流中的序列号ID和被序列化类中的序列号ID做比对，只有两者一致，才能重新反序列化，否则就会报异常来终止反序列化的过程。</p>
<blockquote>
<p>为了<code>serialVersionUID</code>的确定性，建议只要是<code>implements Serializable</code>的类，都最好人为显式地为它声明一个<code>serialVersionUID</code>明确值。</p>
</blockquote>
<blockquote>
<p>如果不想手动赋值，也可以借助IDE的自动添加功能，比如用IntelliJ IDEA，按alt + enter就可以为类自动生成和添加<code>serialVersionUID</code>字段</p>
</blockquote>
<h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a>Kryo</h3><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。</p>
<h3 id="ProtoStuff"><a href="#ProtoStuff" class="headerlink" title="ProtoStuff"></a>ProtoStuff</h3><p>基于 Google protobuf，但是提供了更多的功能和更简易的用法。更加易用。</p>
<h3 id="hession"><a href="#hession" class="headerlink" title="hession"></a>hession</h3><p>hessian 是一个轻量级的,自定义描述的二进制 RPC 协议。hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<h2 id="Java代理实现"><a href="#Java代理实现" class="headerlink" title="Java代理实现"></a>Java代理实现</h2><h2 id="推荐系统架构"><a href="#推荐系统架构" class="headerlink" title="推荐系统架构"></a>推荐系统架构</h2><p>推荐系统架构(数据流图)<br><img src="/2023/07/30/java-knowledge/recommand.jpg" alt="page-recommand1" title="推荐系统架构"></p>
<h2 id="高并发中的集合有哪些问题"><a href="#高并发中的集合有哪些问题" class="headerlink" title="高并发中的集合有哪些问题"></a>高并发中的集合有哪些问题</h2><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><blockquote>
<p>【spring、springboot、springcloud的区别】HTTPs:&#x2F;&#x2F;<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/ecf67d555093">www.jianshu.com/p/ecf67d555093</a><br>【Spring、SpringMVC、SpringBoot、SpringCloud的区别与联系】HTTPs:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1516989</p>
</blockquote>
<h2 id="BeanFactory、ApplicationContext"><a href="#BeanFactory、ApplicationContext" class="headerlink" title="BeanFactory、ApplicationContext"></a>BeanFactory、ApplicationContext</h2>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>hengqu4
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://hengqu4.github.io/2023/07/30/java-knowledge/" title="Java知识库">https://hengqu4.github.io/2023/07/30/java-knowledge/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/26/kafka/" rel="prev" title="kafka">
                  <i class="fa fa-chevron-left"></i> kafka
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/07/31/mysql-knowledge/" rel="next" title="MySQL">
                  MySQL <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">hengqu4</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"width":150,"height":200,"position":"right","hOffset":20,"vOffset":20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
